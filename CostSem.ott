
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  Cost semantics  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

cost :: 'cost_' ::=
  | alloc K :: :: Allocate

t {{ tex \theta }} :: 't_' ::=
  | {} :: :: empty
  | { ccs |-> cost } :: :: inject
  | t <> t' :: :: append

G {{ tex \Gamma }}, D {{ tex \Delta }}, T {{ tex \Theta }} :: 'G_' ::=
  | empty :: :: em
  | G , Gp :: :: vn

Gp :: 'Gp_' ::=
  | x |-> rhs :: :: prod

formula :: 'formula_' ::=
  | judgement :: :: judgement
  % all the random extra stuff we didn't want to gunk up the inductive
  % types with...
  | x |-> rhs in G :: :: Gin
  | G' = G [ </ Gpi // , // i IN 1 .. n /> ] :: :: Gsplit
  | ccs' = enterFunCCS ccs ccs0 :: :: Gccs
  | alt' = alt :: :: Galt

v :: 'v_' ::=
  | \ upd ccs xs . e    :: :: StgRhsClosureReentrant {{ com Restricted to re-entrant closures }}
  | K ccs args        :: :: StgRhsCon

subrules
  v <:: rhs

defns

Jcost :: '' ::=

defn
    ccs , G : e  >- t ->  D : a , ccs' :: :: cost :: ''
        {{tex [[ccs]] [[,]] [[G]] [[:]] [[e]]\ \Downarrow_{[[t]]}\ [[D]] [[:]] [[a]] [[,]] [[ccs']] }}
        by

    --------------------------------------- :: StgLit
    ccs, G : lit  >-{}->  G : lit, ccs

    G' = G [ x |-> v ]
    --------------------------------------- :: StgAppWhnf
    ccs, G' : x nil  >-t->  G' : x, ccs

    ccs0, G' : e  >-t->  D' : y, ccs'
    G' = G [ x |-> \ u ccs0 nil . e ]
    D' = D [ x |-> \ r ccs0 nil . y nil ]
    --------------------------------------- :: StgAppThunk
    ccs, G' : x nil  >-t->  D' : y, ccs'

    D = G [ x |-> \ r ccs0 </ xj // j /> . f </ ai // i /> </ xj // j /> ]
    --------------------------------------- :: StgAppFunUnder
    ccs, G : f </ ai // i /> >- {} -> D : x, ccs
    % NB: PAPs not charged!

    ccs1, G' : e >-t-> D : x, ccs'
    ccs1 = enterFunCCS ccs ccs0
    G' = G [ f |-> \ r ccs0 </ xi // i /> . e ]
    --------------------------------------- :: StgAppFunSat
    ccs, G' : f </ ai // i /> >-t->  D : x, ccs'

    ccs, G : f </ ai // i /> >-t-> D : f', ccs0
    ccs, D : f' </ bj // j /> >-t'-> T : x, ccs'
    ---------------------------------------- :: StgAppFunOver
    ccs, G : f </ ai // i /> </ bj // j /> >-t <> t'->  T : x, ccs'

    D = G [ x |-> K ccs </ ai // i /> ]
    ---------------------------------------- :: StgConApp
    ccs, G : K </ ai // i />  >- { ccs |-> alloc K } ->  D : x, ccs

    D' = D [ x |-> Kk ccs0 </ ai // i /> ]
    altj = Kk </ xi // i /> -> e'
    ccs, G : e >- t -> D' : x, ccs0'
    ccs, D' : e' </ [ ai / xi ] // i /> >- t' -> T : y, ccs'
    --------------------------------------------------------------- :: StgCase
    ccs, G : case e as x of </ altj // j /> >- t <> t' -> T : y, ccs'
